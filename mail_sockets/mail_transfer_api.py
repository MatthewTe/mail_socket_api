# Importing data management packages:
import pandas as pd
from io import StringIO
import os
import datetime as datetime
import pprint
from csv import reader
import base64

# Importing SMTP and email related packages:
import ssl
import smtplib
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

# Importing IMAP related packages:
import imaplib
import imapclient
import pyzmail

# Connection Object for sending data to a SMTP mail server:
class smtp_socket(smtplib.SMTP):
    """
    This is a commuincation object that makes use of the SMTP python package to
    send pipeline relevant information to a SMTP server account.

    This method is meant to operate similarly to the api that allows data to be
    sent through a network socket. It is essetally an object that wraps the
    smtp.SMTP object and allows relevant pipeline data to be uploaded. It is then
    under the assumption that this data is read from the SMTP server via the twin
    object imap_socket().

    See documentation as to why this bootstrap method of making use of email severs
    was used to transfer data as opposed to traditional network sockets.

    Parameters
    ----------
    smtp_server : str
        A string that represents the domain name of the SMTP server. This will
        be used to initalize the smtplib.SMTP object. eg: 'stmp.gmail.com'.

    port : int
        An integer representing the port number used to connect to the SMTP server.

    mail_address : str
        This is the string representing the email address that the method will
        connect to and upload messages to.

    psswrd : str
        The password that will be used to sign into the SMTP server.

    debug : bool
        A boolean dictating whether the debug messages for the object print. By
        default it is set to True.

    """
    def __init__(self, smtp_server, port, mail_address, psswrd, debug=True):

        # Declaring instance variables:
        self.debug = debug
        self.mail_address = mail_address

        # Initalizing the SMTP parent object to connect to mail server:
        super().__init__(smtp_server, port)

        # Performing handshake with the SMTP server and confirming sucess:
        if self.ehlo()[0] == 250:

            self.debug_print(f'[HANDSHAKE WITH {smtp_server} SUCESSFULL]')


        else:
            print(f'[HANDSHAKE WITH {smtp_server} UNSUCESSFULL. ABORTING]')
            return

        # If connecting to sever on port 587, activating TLS encryption:
        if port == 587:

            # Confirming TLS encryption ennabled:
            if 220 == self.starttls()[0]:
                self.debug_print('\n[TLS Encryption ACTIVE]')

        # Logging in to SMTP server:
        if self.login(mail_address, psswrd)[0] == 235:

            self.debug_print(f'[LOGIN TO ACCOUNT {mail_address} SUCESSFULL]')

# <-----------dfs0 7-Day Forecast Pipeline Specific Sending Methods------------>

    # Method designed to send csv data generated from the seven day dfs0_pipeline:
    def send_forecast_data(self, data_path, file_name):
        '''
        Method that sends an email with a csv attachment to the SMTP server. It
        is designed to send a message with the correct formatting to be read by
        the IMAP socket as data generated from the seven day forecast model.

        It is assumed that the data parameter is a .csv file of concatinated
        seven day forecast data generated by the HD model. If it is not many of
        the tagging and formatting processes may not function. See Documentation.

        Parameters
        ----------
        data_path : str
            A string representing the path to the .csv file that is to be attached
            to the message.

        file_name : str
            This is the string that represents the path to the file that will be
            encoded and sent to the mail server.

        '''
        # Accessing the .csv using the data path string:
        csv_path = os.path.abspath(data_path)
        file_name = os.path.split(csv_path)[1]

        # Creating the current datetime string to be built into the Subject string:
        datetime_sent = datetime.datetime.now().strftime('%d/%m/%Y %H:%M')

        # Creating Subject String for Email, used for IMAP type verification:
        # "file_name;file_name;model_type;datetime_sent"
        subject = f"{file_name};{file_name};forecast;{datetime_sent}"

        # Creating the multipart email message:
        csv_message = MIMEMultipart()
        csv_message['From'] = self.mail_address # Sending the email to the same address
        csv_message['To'] = self.mail_address
        csv_message['Subject'] = subject

        # Opening the csv file based on file path:
        with open(csv_path, 'rb') as csv_file:

            # Adding the csv file to the email as application/octet-stream:
            data = MIMEBase('application', 'octet-stream')
            data.set_payload(csv_file.read())

        # Encoding the csv into base64 ASCII characters:
        encoders.encode_base64(data)

        # Adding the attachment header as key/value pair:
        data.add_header("Content-Disposition", f"attachment; filename= {csv_path}")

        # Attaching the csv file to the email:
        csv_message.attach(data)

        # Sending the email:
        send_dict = self.sendmail(self.mail_address, self.mail_address, csv_message.as_string())

        if len(send_dict) == 0:

            self.debug_print(f'[MESSAGE {subject} SENT SUCESSFULLY]')

        else:

            self.debug_print(f'[ERROR IN SENDING MESSAGE] {send_dict}')

        # Closing the session with the SMTP server:
        if self.quit()[0] == 221:

            self.debug_print('[SESSION CLOSED]')

# <-------------------------------"Helper" Functions-------------------------->

    # Method that facilitates debug printing:
    def debug_print(self, message):
        '''
        Debug mehod that allows printing of debug messages if debug=True in
        initalization.

        Parameters
        ---------
        message: str
            The string to be printed if debug=True.

        '''
        if self.debug == True:
            print(message)



# Connection object for extracting data from the IMAP mail server:
class imap_socket(imapclient.IMAPClient):
    """
    This is a commuincation object that is used to extract data from a mail server
    in a form that allows it to be used as a data api.

    The object is intended to serve as the 'sister' method to the smtp_socket()
    object in that it provides an api for structured data retrieval from an IMAP
    email server. See Documentation for more information.

    Parameters
    ----------
    imap_server : str
        A string that represents the domain name of the IMAP server. This will
        be used to initalize the IMAPClient object. eg: 'imap.gmail.com'.

    mail_address : str
        This is the string representing the email address that the method will
        connect to and upload messages to eg: account@gmail.com.

    psswrd : str
        The password that will be used to sign into the IMAP server.

    debug : bool
        A boolean dictating whether the debug messages for the object print. By
        default it is set to True.

    """
    def __init__(self, imap_server, mail_address, psswrd, debug=True):

        # Declaring instance variables:
        self.mail_address = mail_address
        self.imap_server = imap_server
        self.debug = debug

        # Initalizing parent object IMAPClient:
        super().__init__(imap_server, ssl=True)

        # Logging into the IMAP server:
        try: # Try-Catch for debug print:

            login_str = self.login(mail_address, psswrd).decode('utf-8')

            self.debug_print(f'[LOGIN STATUS:] {login_str}')

        except:

            self.debug_print('![LOGIN UNSUCESSFULL EXITING PROGRAM]!')
            return

# <-------------------------Pipeline Specific Reciever Methods----------------->

    # Method that extracts data generated from the seven day forecast dfs0 pipeline:
    def get_forecast_data(self, file_name):
        '''
        This method is intended to be used to extract client specific data from the
        IMAP mail server that was uploaded (by the SMTP socket) from the seven
        day forecast model.

        Parameters
        ----------
        file_name : str
            A string representing the name of the file for which the most recent
            data is to be recieved. This file name must be concsitent with all
            other uses of the file name in the pipeline.

        Returns
        -------
        payload_df : pandas dataframe
            A pandas dataframe containing all the forecasting timeseries data
            extracted from the csv pulled from the IMAP server.

        '''
        # Extracting the contents of the inbox folder of the IMAP server:
        self.select_folder('INBOX', readonly=True)

        # Searching for message where the subject contains the client name:
        uid_lst = self.search(['SUBJECT', f'{file_name}'])

        # Creating dict of mail messages and contents from uid_lst:
        messages = self.fetch(uid_lst, data= ['BODY[]', 'FLAGS'])

        # Declaring an empty dict to be populated with message header datetimes:
        header_datetime_dict = {}

        # Declaring an empty list to be populated with datetime objects:
        datetime_lst = []

        # Iterating through the message keys to search for the correct email:
        for uid in messages:

            # Initalizing the message as a pyzmail object to extract header:
            header = pyzmail.PyzMessage.factory(messages[uid][b'BODY[]']).get_subject()

            # Processing the header for list information:
            header_lst = header.split(';')

            # Parses the header to ensure that this is the correct message:
            if header_lst[0] == file_name: # If the email contains client data:

                date_val = datetime.datetime.strptime(header_lst[-1], '%d/%m/%Y %H:%M')

                # Adding datetime to the dict as key/value {uid: datetime}:
                header_datetime_dict[date_val] = uid

                # Adding datetime object to the list:
                datetime_lst.append(date_val)


        # Sorting date list to find the most recent datetime object:
        most_recent = max(datetime_lst)
        self.debug_print(f'[MOST RECENT EMAIL DATE FOR {file_name}]: {most_recent}')


        # Extracting the corresponding uid for the most recent client email:
        recent_uid = header_datetime_dict[most_recent]

        # Initalizing a message as a pyzmail object:
        pyz_msg = pyzmail.PyzMessage.factory(messages[recent_uid][b'BODY[]'])

        # Iterating through the list of pyzmail mailparts to extract the base64 payload:
        for mailpart in pyz_msg.mailparts:

            try:
                # TODO: ADD Debug information statements about payload.
                csv_string = (pyzmail.decode_text(mailpart.get_payload(),
                    mailpart.charset, None)[0])
            except:
                debug_print('![NO DATA PAYLOAD FOUND]!')

        # Converting csv string to a pandas dataframe through StringIO:
        csv_string_data = StringIO(csv_string)

        # Converting formatted string to dataframe:
        payload_df = pd.read_table(csv_string_data, sep=',')

        # Formatting Dataframe:
        payload_df.rename(columns={payload_df.columns[0]:'Date'}, inplace=True)
        payload_df.set_index('Date', inplace=True)

        # Closing connection to IMAP server:
        self.logout()
        self.debug_print(f'[DATA RETRIEVAL SUCESSFULL:] Closing connection to {self.mail_address}')

        return payload_df

    # Method that clears the SMTP server of all emails with file_name except most recent:
    def clear_forecast_data(self, file_name):
        '''
        This method is intended for maintenance of the IMAP email server. It
        queries the IMAP server for any emails with the input client name. It then
        iterates over all of said emails, permanently deleting all file_name
        messages EXCEPT for the most recent.

        Parameters
        ----------
        file_name : str
            A string representing the name of the file. This file_name must be
            concsitent with all other instances of the file in the pipeline as
            it must match the file_name parameter embeded in the message header.

        '''
        self.debug_print(f"[PERFORMING MAIL DELETION FOR CLIENT:] {file_name}")

        # Extracting the contents of the inbox folder of the IMAP server:
        self.select_folder('INBOX', readonly=False)

        # Searching for message where the subject contains the client name:
        uid_lst = self.search(['SUBJECT', f'{file_name}'])

        # Creating list of mail messages and contents from uid_lst:
        messages = self.fetch(uid_lst, data= ['BODY[]', 'FLAGS'])

        # Declaring dict to be populated with key value pair: {date_val:uid}:
        date_val_dict = {}

        # Iterating over the list of messages to extract mail headers:
        for uid in messages:

            # Initalizing the message as a pyzmail object to extract header:
            header = pyzmail.PyzMessage.factory(messages[uid][b'BODY[]']).get_subject()

            # Processing the header for list information:
            header_lst = header.split(';')

            # Adding conditional to ensure only client specific emails are parse:
            if header_lst[0] == file_name:

                # Adding key-value pair to dict:
                date_val_dict[datetime.datetime.strptime(header_lst[-1],
                '%d/%m/%Y %H:%M')] = uid

        # Creating a sorted list of datetime objects from date_val_dict and
        # selecting the last value (most recent email data):
        most_recent_date = sorted(list(date_val_dict.keys()))[-1]

        # Removing the key/value pair of the most recent email from date_val_dict:
        del date_val_dict[most_recent_date]

        uids_to_be_removed = list(date_val_dict.values())

        self.debug_print(f"[MESSAGES TO BE DELETED BY UIDs:] {uids_to_be_removed}")

        # Marking all messages with the date_val_dict UIDs for deletion:
        self.delete_messages(uids_to_be_removed)

        # Permanently removing all previous emails:
        self.expunge()
        self.debug_print(f"[PREVIOUS MESSAGES FOR {file_name} DELETED]")

        self.logout()
        self.debug_print(f'[DELETION PROCESS SUCESSFULL:] Closing connection to {self.mail_address}')



# <-------------------------------"Helper" Functions-------------------------->

    # Method that facilitates debug printing:
    def debug_print(self, message):
        '''
        Debug mehod that allows printing of debug messages if debug=True in
        initalization.

        Parameters
        ---------
        message: str
            The string to be printed if debug=True.

        '''
        if self.debug == True:
            print(message)
